Project Report
Bulls and Cows Game 
By: 
Hina Vinayak 
Dayana Stephania Cabrera Granados 
Neil Ryan Vanmiddendorp
Oscar Eduardo Reyes



Description 
This game is a code-breaking mind or paper and pencil game for one or more players, the program starts off with displaying all the instructions for the game. The program generates a random 4 digit hexadecimal numbers. The four digits are all unique. To start the game it will ask you press any key. The user enters their guess. Let’s say the random four digit number generated is “a12f” and the users guess is “21ad”. So the game tells you the number of bulls that is correct digit at the correct place, and cows are the correct digits at wrong place. For the above described example number of bulls will be one, for digit one and number of cows will be two for digit 2 and letter a. The game continues with the user guessing the answer. If at any point the user wants to stop playing the game, one can end the game by entering 0 and the program will stop and display the random ally generated hexadecimal number. After the user is able to guess the correct answer, the program will ask the user if they want to continue playing the game. User enters 1 in order to continue playing the game and 0 to not play any further.  
How the program works (What algorithms were used)? 
The project was distributed in four section, for each of us to get one part done. The part was to have a menu for the user to understand the rules for the game play the game. This is where the user decides to play the game or not and enter their guess, and the user input is taken in. Meanwhile, the part is being executed, i.e. generating a random number. To generate the random number we use the system call for $v0 number 42. The system call 42 allows programmer to set a range for the set of numbers we want to use, we load register $a1 with 16, which is the upper limit to the set number. After every bit is generated we store each bit in saved registers and then also save a copy in the temporary registers for the comparison with each generated bit. The final answer is stored in register $s0. If the first generated bit is equal to zero, it branches back to the first step of generating the random number. And the values in register $s0 is shifted left by 4 bits. Then we move on to generating the second digit with same system call and same range for the set number, we store the generated bit in saved register and keep a copy in temporary resister for comparison. Here we check if the value for the first randomly generated bit is not equal to the second generated bit. If the two bits are equal, it branches back to the start point of where the second bit is randomly generated if not, the second bit is “or” in saved register $s0 and again the values are shifted left by 4 bit for the next bit to be added. Moving on to the third generated bit with the same system call and the same range for the set numbers, the third random bit is generated. The third bit is then saved in the register $s0 and a copy is saved in one of the temporary registers, now that the third bit is generated it is checked with the first bit and the second bit, it is here checked if it is equal to the first bit or the second bit, if it is equal the branching takes place to the point where the third random bit is generated. If not, then we move on to save the third bit in register $s0 by using “or” and again shift the values in the registers by 4 bit for the last bit to be added. Moving on with generating the fourth bit we again have the system cal 42 and the range to be set as 16, we store the randomly generated bit in one of the saved register and a copy in one of the temporary registers. Now that we have the fourth bit generated we save in the saved register and a copy is kept in the temporary register for the comparison. We check is the equal to the first, second or the third bit, if any of the bit comes out to be equal, branching takes place to the starting point of where the generation of the fourth bit starts. If not, then we go ahead and save the bit by “or in the register $s0. After the random number is generated and stored in a saved register it jumps to the instruction where the random number generator was called. 
The next instruction used is to call the instructions set, where the gaming instruction are printed. After the instructions are printed the code stops there for a user input to “Press any key to continue”. Then the code moves on with clearing some of the registers. Then we ask the user to enter the hexadecimal number. Then we use the system call to get the input/output and then we use other system call code to read the input of the user. We again clear the registers to ensure the correct arguments are loaded correctly and bytes of the arguments are loaded correctly. Now we start with loading the current byte into a temporary register and then we check for if the current byte is a letter or a digit. If the value in the register is less than 0x40, it is a digit else it is a upper case letter. We then put the current byte in the register in to the place. Now, we read the next byte and increment the counter, while it is equal to 4 it goes back to loading the current byte from the user guess and check on if it is a digit or a letter, where the subroutine algorithm is used to convert the ascii-value of the current byte to the value input by the user. And while the increment counter is equal to four, we get all the four bytes of the user input. As soon as we get the four bytes from the user input call the compare function. The compare subroutine first resets all the registers needed, and makes sure we start with 0 bulls and 0 cows. The first step taken place is to “XOR” the guess and the answer, with which the 0’s will be the number of, bulls i.e. the right character at the right place. Then we mask the entire four bits one at a time and link and jump to the check-bull subroutine, which  check to see if the masked bit is 0, if it is then we branch it to add-bull subroutine. The add-subroutine basically increments the bull counter. The next subroutine the guess goes through is cow’s subroutine. We make sure to preserve the original guess in the register $t0. We bitwise AND immediate the 0x000F0000 and the modified guess in register $t0 and shift logical right by 16 bits. Then we AND the $t0 and 0x0000FFFF and “OR” register t0 and t1. And XOR the answer and the modified guess and store the temporary answer into t1. Now we repeat the step of masking each bit one at a time all over again and link and jump to check-cow subroutine. And the check-cow subroutine calls the add-cow subroutine. After we have checked the bulls and cows, we move towards the printing the number of bulls and cows. When the number of bulls is equal to four that means the user has entered the correct guess. And the wins the game and the code will ask the user if they want to continue playing the game by choosing 1 or end it by entering 0. The user can end the game at any point if they are unable to guess the number by entering 0 as their input. 
Challenges the team faced: 
The biggest challenge was to understand how exactly the individual modules will work when combined with each other. We had individually completed the task of what was assigned to us, but to have it all together and make it work, without registers been over written and data been erased before it was stored in the memory. While we progressed through the project, the subroutines would give us trouble in terms of how it is going to run when called from different subroutines and how the values of the register change or stays the same. With limitations of the register and storing values in them was also a concern. Generating the random number into the register, along with each bit been saved into the register every time every character was been randomly generated to be compared later. Using same registers for taking in the user guess, read every bit, and masking every bit to store the hexadecimal value of the guess. One of the challenges faced was while masking as, at times we would be storing the address instead of the value itself. To get the masking right was also an issue, to figure out the right way to mask the character to numbers and alphabets. When generating the random number the branching was really important. To determine the right branching method was a task. If one were to choose just about any branching, the process to actually get every character to be unique was a question. This program specifically had many iterative loops, and writing that loop in MIPs and have them work it actually would in C was a process. To understand individual instruction and get them working in the loop the right way was important. Understanding jump and link was also important in case of how they were used along with registers and subroutines. Once we had the understanding of everything how the subroutines work around, the register saving the values. The loops, and link and jump were easy to get along with.
Contributions from the team members: 
Hina Vinayak: Generating 4-digit random hexadecimal number
Dayana Stephania Cabrera Granados: The Menu and taking the input from the user
Neil Ryan Vanmiddendorp: Comparing the answer and guess
Oscar Eduardo Reyes: reading the user guess and masking each bit to hexadecimal number
Lesson from the project: 
From this project the most important thing we all learnt was the understanding of the memory and how memory work. How all the information is saved in the system? How the information gets fetched from memory and written into memory. There was something we learnt while we were checking our code that it is really important to always reset your registers as there is no set of rule that tells you if the information in the register is been over written or just basically saying added to the information already in it. It helped us gain a better understanding of subroutines and instructions. It helped us gain better understanding of how loops work. 

